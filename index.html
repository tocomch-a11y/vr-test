<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR STABLE 2026</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 50px 80px; font-size: 30px; background: #fff; color: #000; 
            border: 8px solid #0f0; border-radius: 20px; z-index: 10000; font-weight: bold;
        }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <audio id="audio" autoplay playsinline style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 128, 16, 2, 3),
                new THREE.IcosahedronGeometry(0.4, 1),
                new THREE.TorusGeometry(0.4, 0.15, 16, 100),
                new THREE.OctahedronGeometry(0.5, 0),
                new THREE.TorusKnotGeometry(0.3, 0.05, 128, 32, 7, 11),
                new THREE.DodecahedronGeometry(0.4, 0),
                new THREE.BoxGeometry(0.4, 0.4, 0.4, 4, 4, 4),
                new THREE.SphereGeometry(0.4, 8, 8),
                new THREE.TorusKnotGeometry(0.25, 0.12, 64, 16, 3, 4),
                new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16, 1, true),
                new THREE.TorusGeometry(0.35, 0.2, 8, 20),
                new THREE.CapsuleGeometry(0.2, 0.4, 4, 12)
            ];
        }

        async function startAR() {
            // 1. レンダラーの準備
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.xr.enabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 2. 権限エラーを避けるため、必須項目を「空」にして起動
            try {
                const session = await navigator.xr.requestSession('immersive-ar', {
                    optionalFeatures: ['local-floor', 'hand-tracking'] // すべてオプションにする
                });

                document.body.appendChild(renderer.domElement);
                document.getElementById('arBtn').style.display = 'none';

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                
                initGeos();
                mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
                scene.add(mesh);

                // 3. 空間の取得（viewerは絶対に失敗しない）
                xrRefSpace = await session.requestReferenceSpace('viewer');
                
                // 4. セッションの適用
                await renderer.xr.setSession(session);
                initPeer();
                renderer.setAnimationLoop(render);

                session.addEventListener('end', () => { window.location.reload(); });

            } catch (e) {
                console.error(e);
                // 失敗した場合は即リロードして、ユーザーに再度押してもらう（キャッシュクリアのため）
                window.location.href = window.location.href.split('?')[0] + "?t=" + Date.now();
            }
        }

        document.getElementById('arBtn').onclick = startAR;

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => {
                conn.on('data', d => { window.mD = d; });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play().catch(e => {}); 
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            // 音トリガー形状変化
            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // 視線ターゲット
            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);

            // ハンドトラッキング（座標計算の安定化）
            let handPos = new THREE.Vector3();
            let count = 0;
            const sources = frame.session.inputSources;

            for (let i = 0; i < sources.length; i++) {
                const input = sources[i];
                if (input.hand) {
                    const tip = input.hand.get('index-finger-tip');
                    const pose = tip ? frame.getJointPose(tip, xrRefSpace) : null;
                    if (pose) {
                        handPos.x += pose.transform.position.x;
                        handPos.y += pose.transform.position.y;
                        handPos.z += pose.transform.position.z;
                        count++;
                    }
                }
            }

            if (count > 0) {
                const avgPos = new THREE.Vector3(handPos.x / count, handPos.y / count, handPos.z / count);
                // 'viewer'空間の場合、カメラ座標系なので少し調整が必要な場合があるが
                // 基本的にはこれで手に吸い付く
                mesh.position.lerp(avgPos, 0.2);
                mesh.rotation.y += 0.05 + (d.high * 2.0);
            } else {
                mesh.position.lerp(gaze, 0.1);
                mesh.rotation.y += 0.02;
            }

            mesh.scale.setScalar(0.4 + (d.low * 4.0));
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
