<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR HYPER-STABLE</title>
    <style>
        body { margin: 0; background: transparent; overflow: hidden; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 50px 80px; font-size: 30px; background: #fff; color: #000; 
            border: 10px solid #0f0; border-radius: 20px; z-index: 10000; font-weight: bold;
        }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <audio id="audio" autoplay playsinline style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        function initGeos() {
            // パターン12個（計算負荷を下げつつ複雑に見える設定）
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.08, 64, 12, 2, 3),
                new THREE.IcosahedronGeometry(0.4, 1),
                new THREE.TorusGeometry(0.4, 0.1, 12, 48),
                new THREE.OctahedronGeometry(0.5, 0),
                new THREE.TorusKnotGeometry(0.3, 0.04, 100, 16, 7, 11),
                new THREE.DodecahedronGeometry(0.4, 0),
                new THREE.BoxGeometry(0.4, 0.4, 0.4, 2, 2, 2),
                new THREE.SphereGeometry(0.4, 12, 12),
                new THREE.TorusKnotGeometry(0.25, 0.1, 64, 12, 3, 4),
                new THREE.CylinderGeometry(0.3, 0.3, 0.8, 12, 1, true),
                new THREE.TorusGeometry(0.35, 0.15, 8, 16),
                new THREE.CapsuleGeometry(0.2, 0.4, 4, 8)
            ];
        }

        async function startAR() {
            // 1. レンダラーを先行して透明度100%で作成
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                alpha: true,
                powerPreference: "high-performance" 
            });
            renderer.xr.enabled = true;
            renderer.setClearColor(0x000000, 0);

            try {
                // 2. 「immersive-ar」だけを必須条件にする（これが一番落ちない）
                const session = await navigator.xr.requestSession('immersive-ar', {
                    optionalFeatures: ['local-floor', 'hand-tracking']
                });

                document.body.appendChild(renderer.domElement);
                document.getElementById('arBtn').style.display = 'none';

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                
                initGeos();
                mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
                scene.add(mesh);

                // 3. 参照空間の取得で「local-floor」にこだわらない
                // これがエラーで落ちる最大の原因
                xrRefSpace = await session.requestReferenceSpace('viewer');
                
                await renderer.xr.setSession(session);
                initPeer();
                renderer.setAnimationLoop(render);

                session.addEventListener('end', () => { window.location.reload(); });

            } catch (e) {
                console.error("Critical Failure:", e);
                window.location.reload();
            }
        }

        document.getElementById('arBtn').onclick = startAR;

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => {
                conn.on('data', d => { window.mD = d; });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play().catch(e => {}); 
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            // 形状切り替え
            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // 視線ターゲット（viewer空間なので常にカメラ基準で計算）
            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);

            // ハンドトラッキング
            let handPos = new THREE.Vector3();
            let count = 0;
            const sources = frame.session.inputSources;

            for (let i = 0; i < sources.length; i++) {
                if (sources[i].hand) {
                    const tip = sources[i].hand.get('index-finger-tip');
                    // ここでxrRefSpace（viewer）を基準にポーズを取る
                    const pose = tip ? frame.getJointPose(tip, xrRefSpace) : null;
                    if (pose) {
                        handPos.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                        count++;
                    }
                }
            }

            if (count > 0) {
                // 手の位置へ吸いつく
                mesh.position.lerp(handPos, 0.2);
                mesh.rotation.y += 0.05 + (d.high * 2.0);
            } else {
                // 手がない時は視線の正面
                mesh.position.lerp(gaze, 0.1);
                mesh.rotation.y += 0.02;
            }

            // 音量（low）による巨大化
            mesh.scale.setScalar(0.4 + (d.low * 4.0));
            // 中音（mid）による色相変化
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
