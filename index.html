<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Instant AR Quest</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #arBtn { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 50px 100px; font-size: 32px; background: #00ffff; border: none; 
            border-radius: 20px; font-weight: bold; cursor: pointer; z-index: 1000;
        }
        #status { position: absolute; bottom: 10%; width: 100%; text-align: center; color: white; font-family: sans-serif; }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <div id="status">PeerJS Initializing...</div>
    <audio id="remoteAudio" autoplay></audio>

    <script type="module">
        let scene, camera, renderer, activeMesh;
        let macData = { low: 0, mid: 0, high: 0, trigger: false };
        let currentIdx = 0, lastSwitch = 0, hueBase = 0;
        const geometries = [];

        // --- 事前準備 ---
        const initGraphics = () => {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.xr.enabled = true;

            const baseGeos = [
                new THREE.TorusGeometry(3, 0.1, 8, 32), new THREE.IcosahedronGeometry(3, 1),
                new THREE.TorusKnotGeometry(3, 0.5, 64, 8), new THREE.BoxGeometry(4, 4, 4),
                new THREE.OctahedronGeometry(3, 0), new THREE.SphereGeometry(3, 12, 12),
                new THREE.CylinderGeometry(2, 2, 8, 12), new THREE.DodecahedronGeometry(3, 0),
                new THREE.TorusGeometry(3, 1.2, 5, 6), new THREE.ConeGeometry(3, 8, 12),
                new THREE.TorusKnotGeometry(3, 0.1, 80, 3), new THREE.CapsuleGeometry(2, 4, 2, 12)
            ];
            geometries.push(...baseGeos);
            activeMesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({wireframe: true, transparent: true}));
            scene.add(activeMesh);
        };

        // --- PeerJS (Macとの通信) ---
        const peer = new Peer('psy-link-stable-quest');
        peer.on('open', () => document.getElementById('status').innerText = "Peer Ready. Press START AR.");
        peer.on('call', call => {
            call.answer(new MediaStream());
            call.on('stream', stream => document.getElementById('remoteAudio').srcObject = stream);
        });
        peer.on('connection', conn => {
            conn.on('data', data => { macData = data; });
        });

        initGraphics();

        // --- AR起動の鍵：一切の非同期を挟まない ---
        const btn = document.getElementById('arBtn');
        btn.onclick = () => {
            // navigator.xr.requestSession は必ず関数の直下で呼ぶ
            navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hand-tracking']
            }).then((session) => {
                btn.style.display = 'none';
                document.getElementById('status').style.display = 'none';
                
                renderer.xr.setSession(session);
                renderer.setAnimationLoop(render);
            }).catch(err => {
                document.getElementById('status').innerText = "Error: " + err.message;
                console.error(err);
            });
        };

        function render(time, frame) {
            hueBase += 0.005;

            // Mac側からのトリガーで形状変化
            if (macData.trigger && Date.now() - lastSwitch > 800) {
                currentIdx = (currentIdx + 1) % 12;
                activeMesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            // ハンドトラッキング
            if (frame) {
                const session = frame.session;
                for (const source of session.inputSources) {
                    if (source.hand) {
                        const indexTip = source.hand.get('index-finger-tip');
                        const wrist = source.hand.get('wrist');
                        const pIdx = frame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                        const pWri = frame.getJointPose(wrist, renderer.xr.getReferenceSpace());
                        if (pIdx && pWri) {
                            const pos = pIdx.transform.position;
                            activeMesh.position.set(pos.x, pos.y, pos.z);
                            const dist = Math.hypot(pos.x-pWri.transform.position.x, pos.y-pWri.transform.position.y) * 10;
                            const s = 0.5 + (macData.low * 2) + dist;
                            activeMesh.scale.set(s, s, s);
                        }
                    }
                }
            }

            activeMesh.rotation.y += 0.02 + macData.high * 0.2;
            activeMesh.material.color.setHSL((hueBase + macData.mid)%1, 1, 0.5);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
