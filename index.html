<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Psy-XR IRONCLAD</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; }
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,1); z-index: 9999; }
        #arBtn { padding: 40px 80px; font-size: 32px; background: #222; color: #fff; border: 4px solid #fff; border-radius: 15px; cursor: pointer; }
        #arBtn.active { background: #00ffff; color: #000; border: 4px solid #fff; }
        #status { color: #0f0; margin-top: 20px; font-size: 16px; text-align: center; }
    </style>
</head>
<body>
    <div id="ui">
        <button id="arBtn">WAITING FOR MAC...</button>
        <div id="status">INIT PEER...</div>
    </div>
    <audio id="remoteAudio" autoplay></audio>

    <script>
        const btn = document.getElementById('arBtn');
        const status = document.getElementById('status');
        let macData = { low: 0, mid: 0, high: 0, trigger: false };
        let renderer, scene, camera, mesh, geometries = [];
        let currentIdx = 0, lastSwitch = 0, hue = 0;

        // --- 1. Peer Setup (Immediate) ---
        const peer = new Peer('quest-receiver');
        peer.on('open', (id) => { status.innerText = "Target ID: quest-receiver\nCONNECT FROM MAC"; });
        peer.on('connection', conn => {
            status.innerText = "MAC CONNECTED!";
            btn.innerText = "ENTER AR";
            btn.classList.add('active');
            conn.on('data', data => { macData = data; });
        });
        peer.on('call', call => {
            call.answer(new MediaStream());
            call.on('stream', s => { document.getElementById('remoteAudio').srcObject = s; });
        });

        // --- 2. Graphics Setup (Hidden until AR starts) ---
        function initGraphics() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            // Geometry generation
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 128, 16),
                new THREE.IcosahedronGeometry(0.4, 1),
                new THREE.TorusGeometry(0.4, 0.05, 16, 64)
            ];
            mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, transparent: true, opacity: 0.8 }));
            mesh.position.set(0, 1.2, -0.5); // 50cm in front of you
            scene.add(mesh);
        }

        // --- 3. AR Entry (Synchronous Execution) ---
        btn.onclick = async () => {
            if (!renderer) initGraphics();
            
            try {
                const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor', 'hand-tracking']
                });
                
                await renderer.xr.setSession(session);
                document.getElementById('ui').style.display = 'none';
                
                // FORCE THE RENDER LOOP
                renderer.setAnimationLoop(render);
            } catch (e) {
                status.innerText = "XR ERROR: " + e.message;
            }
        };

        function render(time, frame) {
            if (!frame) return;
            hue += 0.005;

            // Mode switch on trigger
            if (macData.trigger && (Date.now() - lastSwitch > 700)) {
                currentIdx = (currentIdx + 1) % geometries.length;
                mesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            // Hand Tracking
            const session = frame.session;
            const refSpace = renderer.xr.getReferenceSpace();
            for (const input of session.inputSources) {
                if (input.hand) {
                    const tip = input.hand.get('index-finger-tip');
                    const pose = frame.getJointPose(tip, refSpace);
                    if (pose) {
                        mesh.position.lerp(new THREE.Vector3().copy(pose.transform.position), 0.2);
                        mesh.quaternion.slerp(new THREE.Quaternion().copy(pose.transform.orientation), 0.1);
                    }
                }
            }

            // Fallback Animation
            mesh.rotation.y += 0.01;
            mesh.scale.setScalar(1 + (macData.low * 2));
            mesh.material.color.setHSL((hue + macData.mid) % 1, 0.8, 0.5);
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
