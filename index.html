<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Quest AR - Mac Powered</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #overlay { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.8); z-index: 100; }
        button { padding: 40px; font-size: 24px; background: #ff00ff; color: white; border: none; border-radius: 50px; font-weight: bold; }
        #status { color: #00ffff; margin-bottom: 20px; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="status">Macの送信開始を待ってください...</div>
        <button id="arBtn" style="display:none;">ENTER PSYCHEDELIC AR</button>
    </div>
    <audio id="remoteAudio" autoplay></audio>

    <script type="module">
        let scene, camera, renderer, activeMesh;
        let macData = { low: 0, mid: 0, high: 0, modeTrigger: false };
        let currentIdx = 0, lastSwitch = 0, hueBase = 0;
        const geometries = [];

        const peer = new Peer('psy-link-stable-quest');
        
        // 音声の受信
        peer.on('call', call => {
            call.answer(new MediaStream());
            call.on('stream', stream => {
                document.getElementById('remoteAudio').srcObject = stream;
                document.getElementById('status').innerText = "音声受信中...";
            });
        });

        // Macからの解析データの受信（負荷の高い計算はMacが済ませている）
        peer.on('connection', conn => {
            conn.on('data', data => {
                macData = data;
                document.getElementById('arBtn').style.display = "block";
                document.getElementById('status').innerText = "データリンク完了！";
            });
        });

        document.getElementById('arBtn').onclick = () => startAR();

        async function startAR() {
            // WebXRの初期化
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            createGeometries();
            activeMesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({wireframe: true}));
            scene.add(activeMesh);

            // セッション要求（必ずクリックイベント内で実行）
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hand-tracking']
            });
            renderer.xr.setSession(session);
            document.getElementById('overlay').style.display = 'none';

            renderer.setAnimationLoop(render);
        }

        function createGeometries() {
            const base = [
                new THREE.TorusGeometry(10, 0.5, 8, 32),
                new THREE.IcosahedronGeometry(8, 1),
                new THREE.TorusKnotGeometry(7, 2, 64, 8),
                new THREE.BoxGeometry(10, 10, 10),
                new THREE.OctahedronGeometry(8, 0),
                new THREE.SphereGeometry(8, 12, 12),
                new THREE.CylinderGeometry(5, 5, 15, 12),
                new THREE.DodecahedronGeometry(8, 0),
                new THREE.TorusGeometry(8, 3, 5, 6),
                new THREE.ConeGeometry(7, 12, 12),
                new THREE.TorusKnotGeometry(7, 0.2, 80, 3),
                new THREE.CapsuleGeometry(4, 8, 2, 12)
            ];
            geometries.push(...base);
        }

        function render(time, frame) {
            hueBase += 0.005;

            // Macから届いたmodeTriggerでモード変更
            if (macData.modeTrigger && Date.now() - lastSwitch > 800) {
                currentIdx = (currentIdx + 1) % 12;
                activeMesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            // ハンドトラッキング（最小限）
            let handScale = 1;
            if (frame) {
                const inputSources = frame.session.inputSources;
                for (const input of inputSources) {
                    if (input.hand) {
                        const indexTip = input.hand.get('index-finger-tip');
                        const wrist = input.hand.get('wrist');
                        const p1 = frame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                        const p2 = frame.getJointPose(wrist, renderer.xr.getReferenceSpace());
                        if (p1 && p2) {
                            handScale = Math.hypot(p1.transform.position.x - p2.transform.position.x, p1.transform.position.y - p2.transform.position.y) * 15;
                            activeMesh.position.set(p1.transform.position.x, p1.transform.position.y, p1.transform.position.z);
                        }
                    }
                }
            }

            // Mac側の解析結果をビジュアルに反映
            const s = 0.5 + macData.low * 3 + handScale;
            activeMesh.scale.set(s, s, s);
            activeMesh.rotation.y += 0.02 + macData.high * 0.2;
            activeMesh.material.color.setHSL((hueBase + macData.mid)%1, 1, 0.5);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
