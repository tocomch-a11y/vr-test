<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Psychedelic AR Ultra</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #overlay { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; background: rgba(0,0,0,0.8); z-index: 100; }
        button { padding: 30px 60px; font-size: 24px; background: #ff00ff; color: white; border: none; border-radius: 50px; cursor: pointer; margin: 10px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="status">接続待機中...</div>
        <div id="btnContainer" style="display:none;">
            <button onclick="initXR('immersive-vr')">VR START</button>
            <button onclick="initXR('immersive-ar')">AR START</button>
        </div>
    </div>
    <audio id="remoteAudio" autoplay></audio>

    <script type="module">
        import { VRButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/VRButton.js';

        let scene, camera, renderer, analyzer, dataL, audioCtx;
        let currentMode = 'Y', autoMode = false, isRightTrigger = false;
        let lastAutoSwitch = 0, hueBase = 0;
        const groups = { A: new THREE.Group(), B: new THREE.Group(), X: new THREE.Group(), Y: new THREE.Group() };

        const peer = new Peer('psy-link-stable-quest');
        peer.on('call', call => {
            call.answer(new MediaStream());
            call.on('stream', stream => {
                document.getElementById('remoteAudio').srcObject = stream;
                document.getElementById('status').innerText = "Connected!";
                document.getElementById('btnContainer').style.display = "block";
                window.remoteStream = stream;
            });
        });

        window.initXR = async (mode) => {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            await audioCtx.resume();
            const source = audioCtx.createMediaStreamSource(window.remoteStream);
            analyzer = audioCtx.createAnalyser();
            analyzer.fftSize = 512;
            source.connect(analyzer);
            dataL = new Uint8Array(analyzer.frequencyBinCount);
            source.connect(audioCtx.destination);
            document.getElementById('overlay').style.display = 'none';
            setupThreeJS(mode);
        };

        function setupThreeJS(mode) {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            navigator.xr.requestSession(mode, { optionalFeatures: ['local-floor'] }).then(s => renderer.xr.setSession(s));

            createModeY(); createModeB(); createModeX(); createModeA();
            Object.values(groups).forEach(g => { g.visible = false; scene.add(g); });
            groups.Y.visible = true;
            animate();
        }

        // --- Y: 高密度スペクトラム・リング ---
        function createModeY() {
            for(let j=0; j<40; j++) { // リング数を40に増加
                const geo = new THREE.BufferGeometry();
                const pts = new Float32Array(128 * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
                const line = new THREE.LineLoop(geo, new THREE.LineBasicMaterial({transparent: true}));
                groups.Y.add(line);
            }
        }

        // --- B: レインボー・ベジェ・ストリーム ---
        function createModeB() {
            for(let i=0; i<8; i++) {
                const geo = new THREE.BufferGeometry();
                const pts = new Float32Array(100 * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
                const line = new THREE.Line(geo, new THREE.LineBasicMaterial({linewidth: 2}));
                groups.B.add(line);
            }
        }

        // --- X: 全方位サイケ・カオス ---
        function createModeX() {
            const geotypes = [new THREE.IcosahedronGeometry(2,0), new THREE.TorusGeometry(2,0.5,8,16), new THREE.BoxGeometry(2,2,2)];
            for(let i=0; i<60; i++) {
                const mesh = new THREE.Mesh(geotypes[i%3], new THREE.MeshBasicMaterial({wireframe: true}));
                mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                groups.X.add(mesh);
            }
        }

        // --- A: ネオン・グリッド・カレイドスコープ (再設計) ---
        function createModeA() {
            for(let i=0; i<100; i++) {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5, 5), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, wireframe:true}));
                groups.A.add(mesh);
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const session = renderer.xr.getSession();
                if (session) {
                    for (const source of session.inputSources) {
                        const b = source.gamepad.buttons;
                        if (source.handedness === 'right') {
                            if (b[4]?.pressed) switchM('A');
                            if (b[5]?.pressed) switchM('B');
                            isRightTrigger = b[0]?.pressed;
                        } else {
                            if (b[4]?.pressed) switchM('X');
                            if (b[5]?.pressed) switchM('Y');
                            if (b[0]?.pressed && Date.now() - lastAutoSwitch > 500) { autoMode = !autoMode; lastAutoSwitch = Date.now(); }
                        }
                    }
                }

                if (analyzer) {
                    analyzer.getByteFrequencyData(dataL);
                    const low = dataL[5]/255, mid = dataL[20]/255, high = dataL[60]/255;
                    hueBase += 0.003;

                    if ((autoMode || isRightTrigger) && low > 0.8 && Date.now() - lastAutoSwitch > 300) {
                        switchM(['A','B','X','Y'][Math.floor(Math.random()*4)]);
                        lastAutoSwitch = Date.now();
                    }

                    if (currentMode === 'Y') {
                        groups.Y.children.forEach((line, j) => {
                            const pos = line.geometry.attributes.position.array;
                            const rBase = j * 0.8; // 中央から埋め尽くす
                            for(let i=0; i<128; i++) {
                                const a = (i/128)*Math.PI*2;
                                const f = dataL[i%128]/255; // スペクトラム連動
                                const r = rBase + f * (5 + j*0.2);
                                pos[i*3] = Math.cos(a)*r; pos[i*3+1] = Math.sin(a)*r; pos[i*3+2] = -j*5;
                            }
                            line.geometry.attributes.position.needsUpdate = true;
                            line.material.color.setHSL((hueBase + j*0.02)%1, 1, 0.5);
                            line.material.opacity = 1.0 - (j/40);
                        });
                    } else if (currentMode === 'B') {
                        groups.B.children.forEach((line, j) => {
                            const pos = line.geometry.attributes.position.array;
                            for(let i=0; i<100; i++) {
                                pos[i*3] = Math.sin(i*0.1 + hueBase*j)*20;
                                pos[i*3+1] = Math.cos(i*0.1 + mid*5)*20;
                                pos[i*3+2] = -i*2;
                            }
                            line.geometry.attributes.position.needsUpdate = true;
                            line.material.color.setHSL((hueBase + j*0.13)%1, 1, 0.5); // 線ごとに色を変える
                        });
                    } else if (currentMode === 'X') {
                        groups.X.children.forEach((m, i) => {
                            m.position.x += Math.sin(Date.now()*0.001 + i)*mid;
                            m.position.y += Math.cos(Date.now()*0.001 + i)*low;
                            m.position.z += Math.sin(Date.now()*0.002 + i)*high;
                            if(m.position.length() > 100) m.position.setScalar(0);
                            m.rotation.x += 0.02;
                            m.material.color.setHSL((hueBase + i*0.05)%1, 1, 0.5);
                        });
                    } else if (currentMode === 'A') {
                        groups.A.children.forEach((m, i) => {
                            const a = (i/100)*Math.PI*2;
                            const r = 30 + low*20;
                            m.position.set(Math.cos(a + hueBase)*r, Math.sin(a + hueBase)*r, -50 + Math.sin(hueBase*5 + i)*20);
                            m.rotation.z = a + hueBase;
                            m.material.color.setHSL((hueBase + i*0.01)%1, 1, 0.5);
                        });
                    }
                }
                renderer.render(scene, camera);
            });
        }

        function switchM(m) {
            currentMode = m;
            Object.keys(groups).forEach(k => groups[k].visible = (k === m));
        }
    </script>
</body>
</html>
