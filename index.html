<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psy-XR Hand Tracking</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 60px 100px; font-size: 40px; background: #ff00ff; color: white;
            border: 8px solid #fff; border-radius: 20px; font-weight: bold; z-index: 9999;
            cursor: pointer;
        }
        #status { position: fixed; bottom: 20px; width: 100%; text-align: center; color: #0f0; font-family: monospace; z-index: 1000; }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <div id="status">INITIALIZING...</div>
    <audio id="remoteAudio" autoplay></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        const btn = document.getElementById('arBtn');
        const status = document.getElementById('status');
        let macData = { low: 0, mid: 0, high: 0, trigger: false };
        let renderer, scene, camera, mesh, geometries = [];
        let currentIdx = 0, lastSwitch = 0, hue = 0;

        btn.onclick = () => {
            if (!navigator.xr) {
                status.innerText = "WEBXR NOT SUPPORTED";
                return;
            }
            navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hand-tracking']
            }).then(setupXR).catch(err => {
                status.innerText = "XR ERROR: " + err.message;
            });
        };

        function setupXR(session) {
            btn.style.display = 'none';
            status.innerText = "XR ACTIVE - WAITING FOR MAC";

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.xr.enabled = true;
            renderer.setPixelRatio(1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.setSession(session);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);

            createGeos();
            const mat = new THREE.MeshBasicMaterial({ wireframe: true, transparent: true, opacity: 0.8 });
            mesh = new THREE.Mesh(geometries[0], mat);
            scene.add(mesh);

            initPeer();
            renderer.setAnimationLoop(render);
        }

        function createGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(1, 0.4, 128, 16),
                new THREE.IcosahedronGeometry(1.5, 1),
                new THREE.TorusGeometry(2, 0.05, 16, 100),
                new THREE.OctahedronGeometry(1.5, 0),
                new THREE.TorusKnotGeometry(1.5, 0.1, 200, 3, 3, 5),
                new THREE.BoxGeometry(2, 2, 2, 4, 4, 4),
                new THREE.DodecahedronGeometry(1.5, 0),
                new THREE.TorusGeometry(1.5, 0.8, 12, 6),
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.ConeGeometry(1.5, 3, 32, 1, true),
                new THREE.TorusKnotGeometry(1.2, 0.6, 64, 4),
                new THREE.CapsuleGeometry(1, 2, 4, 16)
            ];
        }

        function initPeer() {
            const peer = new Peer('psy-link-stable-quest');
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', stream => {
                    document.getElementById('remoteAudio').srcObject = stream;
                    status.innerText = "CONNECTED - AUDIO STREAMING";
                });
            });
            peer.on('connection', conn => {
                conn.on('data', data => { macData = data; });
            });
        }

        function render(time, frame) {
            hue += 0.005;

            if (macData.trigger && Date.now() - lastSwitch > 600) {
                currentIdx = Math.floor(Math.random() * 12);
                mesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            if (frame) {
                const sources = frame.session.inputSources;
                for (const input of sources) {
                    if (input.hand) {
                        const tip = frame.getJointPose(input.hand.get('index-finger-tip'), renderer.xr.getReferenceSpace());
                        const wrist = frame.getJointPose(input.hand.get('wrist'), renderer.xr.getReferenceSpace());
                        if (tip && wrist) {
                            const tPos = tip.transform.position;
                            const wPos = wrist.transform.position;
                            mesh.position.lerp(new THREE.Vector3(tPos.x, tPos.y, tPos.z), 0.2);
                            const dist = Math.hypot(tPos.x - wPos.x, tPos.y - wPos.y, tPos.z - wPos.z);
                            mesh.scale.setScalar(0.5 + (dist * 6) + (macData.low * 2));
                        }
                    }
                }
            }

            mesh.rotation.x += 0.01 + macData.mid * 0.1;
            mesh.rotation.y += 0.02 + macData.high * 0.2;
            mesh.material.color.setHSL((hue + macData.mid) % 1, 0.8, 0.5 + macData.low * 0.2);
            mesh.material.opacity = 0.4 + macData.low * 0.6;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
