<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Psychedelic VR/AR Link</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #overlay { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; background: rgba(0,0,0,0.9); z-index: 100; }
        .id-label { font-size: 24px; color: #00ffff; margin: 10px; padding: 10px; border: 2px solid #00ffff; border-radius: 10px; }
        button { padding: 20px 40px; font-size: 18px; background: #ff00ff; color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin: 10px; }
        #mode-info { position: fixed; bottom: 20px; width: 100%; text-align: center; color: #00ffff; font-size: 1.2em; pointer-events: none; z-index: 50; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>Advanced Psychedelic Link</h1>
        <div id="idLabel" class="id-label">----</div>
        <div id="actionArea"><p>Macから送信してください</p></div>
        <div id="xr-options" style="display:none;">
            <button onclick="startApp('immersive-vr')">VRモードで開始</button>
            <button onclick="startApp('immersive-ar')">ARモードで開始</button>
        </div>
    </div>
    <div id="mode-info">A,B,X,Y: 切替 / 右トリガー: ランダム</div>
    <audio id="remoteAudio" autoplay></audio>

    <script type="module">
        import { VRButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/VRButton.js';

        let scene, camera, renderer, analyzer, dataArray, audioCtx;
        let currentMode = 'Y', isRandom = false, lastRandomTime = 0;
        const groups = { A: new THREE.Group(), B: new THREE.Group(), X: new THREE.Group(), Y: new THREE.Group() };
        let hueBase = 0;

        // PeerJS Setup
        const questId = 'vr-psy-' + Math.floor(Math.random() * 999);
        const peer = new Peer(questId);
        peer.on('open', id => document.getElementById('idLabel').innerText = id);
        peer.on('call', call => {
            call.answer(new MediaStream());
            call.on('stream', stream => {
                document.getElementById('remoteAudio').srcObject = stream;
                document.getElementById('actionArea').innerHTML = "通信確立！モードを選択してください";
                document.getElementById('xr-options').style.display = "block";
                window.remoteStream = stream;
            });
        });

        window.startApp = async (sessionType) => {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            await audioCtx.resume();
            const source = audioCtx.createMediaStreamSource(window.remoteStream);
            analyzer = audioCtx.createAnalyser();
            analyzer.fftSize = 256;
            source.connect(analyzer);
            source.connect(audioCtx.destination);
            dataArray = new Uint8Array(analyzer.frequencyBinCount);
            
            document.getElementById('overlay').style.display = 'none';
            initThreeJS(sessionType);
        };

        function initThreeJS(sessionType) {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // VR/ARボタンの設置（自動開始を試みる）
            const xrBtn = VRButton.createButton(renderer, { sessionInit: { optionalFeatures: ['local-floor', 'bounded-floor', 'layers'] } });
            document.body.appendChild(xrBtn);

            setupModes();
            Object.values(groups).forEach(g => scene.add(g));
            switchMode('Y');
            animate();
        }

        function setupModes() {
            // モード Y: ギザギザ・リング
            for(let j=0; j<15; j++) {
                const shape = new THREE.BufferGeometry();
                const points = [];
                for(let i=0; i<=128; i++) points.push(new THREE.Vector3(0,0,0));
                shape.setFromPoints(points);
                const line = new THREE.LineLoop(shape, new THREE.LineBasicMaterial({color: 0x00ffff}));
                line.position.z = -j * 8;
                groups.Y.add(line);
            }

            // モード A: サイケ・トンネル
            const tunnelGeo = new THREE.TorusGeometry(20, 10, 32, 100);
            const tunnelMat = new THREE.MeshBasicMaterial({wireframe: true});
            const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
            tunnel.rotation.x = Math.PI/2;
            groups.A.add(tunnel);

            // モード B: プリズム・バースト
            for(let i=0; i<80; i++) {
                const p = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({wireframe:true}));
                p.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, -Math.random()*150);
                groups.B.add(p);
            }

            // モード X: 歪むグリッド
            const grid = new THREE.GridHelper(200, 30, 0xff00ff, 0x00ffff);
            grid.position.y = -10;
            groups.X.add(grid);
        }

        function switchMode(m) {
            currentMode = m;
            Object.keys(groups).forEach(key => groups[key].visible = (key === m));
            document.getElementById('mode-info').innerText = (isRandom ? "VJ RANDOM MODE: " : "MODE: ") + m;
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const session = renderer.xr.getSession();
                if (session) {
                    for (const source of session.inputSources) {
                        if (source.gamepad) {
                            const b = source.gamepad.buttons;
                            // モード切替
                            if (b[4]?.pressed) switchMode('X'); 
                            if (b[5]?.pressed) switchMode('Y');
                            if (source.handedness === 'right' && b[4]?.pressed) switchMode('A');
                            if (source.handedness === 'right' && b[5]?.pressed) switchMode('B');
                            // ランダムモード (右トリガー)
                            if (source.handedness === 'right' && b[0]?.pressed) isRandom = true;
                            else if (source.handedness === 'right') isRandom = false;
                        }
                    }
                }

                if (analyzer) {
                    analyzer.getByteFrequencyData(dataArray);
                    const low = dataArray[5]/255, mid = dataArray[20]/255, high = dataArray[60]/255;
                    hueBase += 0.003;

                    // ランダムモードのロジック (低音が強い時に切替)
                    if (isRandom && low > 0.8 && Date.now() - lastRandomTime > 400) {
                        const m = ['A','B','X','Y'][Math.floor(Math.random()*4)];
                        switchMode(m);
                        lastRandomTime = Date.now();
                    }

                    if (currentMode === 'Y') {
                        groups.Y.children.forEach((line, j) => {
                            const positions = line.geometry.attributes.position.array;
                            const rBase = 15 + j;
                            for(let i=0; i<=128; i++) {
                                const angle = (i / 128) * Math.PI * 2;
                                const freqIdx = Math.floor(i % (dataArray.length/2));
                                const distort = (dataArray[freqIdx]/255) * (5 + j*0.5);
                                positions[i*3] = Math.cos(angle) * (rBase + distort);
                                positions[i*3+1] = Math.sin(angle) * (rBase + distort);
                            }
                            line.geometry.attributes.position.needsUpdate = true;
                            line.material.color.setHSL((hueBase + j*0.05)%1, 1, 0.5);
                            line.position.z = ((j * 10 + Date.now()*0.05) % 150) - 150;
                        });
                    } else if (currentMode === 'A') {
                        groups.A.children[0].rotation.z += 0.01 + low*0.1;
                        groups.A.children[0].scale.setScalar(1 + low);
                        groups.A.children[0].material.color.setHSL(hueBase%1, 1, 0.5);
                    } else if (currentMode === 'B') {
                        groups.B.children.forEach((p, i) => {
                            p.rotation.x += 0.05; p.rotation.y += mid*0.2;
                            p.position.z += 0.5 + low*5;
                            if(p.position.z > 20) p.position.z = -150;
                            p.material.color.setHSL((hueBase + i*0.02)%1, 1, 0.6);
                        });
                    } else if (currentMode === 'X') {
                        groups.X.children[0].position.z = (Date.now()*0.1) % 10;
                        groups.X.children[0].position.y = -10 + low*10;
                        groups.X.children[0].material.color.setHSL((hueBase + mid)%1, 1, 0.5);
                    }
                }
                renderer.render(scene, camera);
            });
        }
    </script>
</body>
</html>
