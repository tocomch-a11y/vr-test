<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR RECOVERY</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #arBtn { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 60px; font-size: 30px; background: #0ff; border: none; border-radius: 20px; z-index: 10001; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <audio id="audio" autoplay playsinline></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script>
        let scene, camera, renderer, mesh, xrRefSpace, geometries = [];
        let macData = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;
        const audio = document.getElementById('audio');

        // Geometries
        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.4, 0.1, 128, 16, 2, 3), new THREE.IcosahedronGeometry(0.5, 1),
                new THREE.TorusGeometry(0.5, 0.15, 16, 100), new THREE.OctahedronGeometry(0.6, 0),
                new THREE.TorusKnotGeometry(0.4, 0.05, 128, 16, 7, 11), new THREE.DodecahedronGeometry(0.5, 0),
                new THREE.BoxGeometry(0.6, 0.6, 0.6, 4, 4, 4), new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.TorusKnotGeometry(0.3, 0.15, 100, 16, 3, 4), new THREE.CylinderGeometry(0.5, 0.5, 1),
                new THREE.TorusGeometry(0.4, 0.2, 8, 20), new THREE.CapsuleGeometry(0.3, 0.5, 4, 16)
            ];
        }

        const btn = document.getElementById('arBtn');
        btn.onclick = () => {
            // WebXR session request
            navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor', 'hand-tracking']
            }).then(session => {
                btn.style.display = 'none';
                setupWebXR(session);
            }).catch(e => {
                alert("AR Start Failed: " + e.message);
            });
        };

        function setupWebXR(session) {
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.xr.enabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            
            initGeos();
            mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ffff }));
            scene.add(mesh);

            session.requestReferenceSpace('local-floor').then(ref => {
                xrRefSpace = ref;
                renderer.xr.setSession(session);
                // 通信を後回しにして起動を優先
                setTimeout(initPeer, 1000);
                renderer.setAnimationLoop(render);
            });
        }

        function initPeer() {
            // ID衝突を避けるためのランダムID
            const peer = new Peer('quest-receiver-' + Math.floor(Math.random()*100));
            // Mac側もこのIDに接続するように修正が必要な場合は後述
            peer.on('open', (id) => console.log("Peer ID:", id));
            peer.on('connection', conn => conn.on('data', d => {
                macData.low = d.low || 0; macData.mid = d.mid || 0;
                macData.high = d.high || 0; macData.trigger = !!d.trigger;
            }));
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { audio.srcObject = s; audio.play(); });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;

            if (macData.trigger && (Date.now() - lastSwitch > 400)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // Gaze & Multi-Hand Tracking
            const gazeDir = new THREE.Vector3(0, 0, -0.7).applyQuaternion(camera.quaternion).add(camera.position);
            let totalPos = new THREE.Vector3();
            let count = 0;

            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    const joints = ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-tip'];
                    joints.forEach(j => {
                        const pose = frame.getJointPose(input.hand.get(j), xrRefSpace);
                        if (pose) { totalPos.add(pose.transform.position); count++; }
                    });
                }
            }

            if (count > 0) {
                const avgPos = totalPos.divideScalar(count);
                mesh.position.lerp(avgPos, 0.2);
                mesh.rotation.y += 0.05 + (count * 0.01) + macData.high;
            } else {
                mesh.position.lerp(gazeDir, 0.05);
                mesh.rotation.y += 0.01;
            }

            mesh.scale.setScalar(0.6 + (macData.low * 2.5));
            mesh.material.color.setHSL((hue + macData.mid) % 1, 1, 0.5 + macData.high * 0.2);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
