<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR ULTIMATE</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 40px 80px; font-size: 30px; background: #fff; color: #000; 
            border: none; border-radius: 15px; z-index: 9999; font-weight: bold;
        }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <audio id="audio" autoplay playsinline style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        // 12パターンの幾何学
        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 128, 16, 2, 3),
                new THREE.IcosahedronGeometry(0.4, 1),
                new THREE.TorusGeometry(0.4, 0.15, 16, 100),
                new THREE.OctahedronGeometry(0.5, 0),
                new THREE.TorusKnotGeometry(0.3, 0.05, 128, 32, 7, 11),
                new THREE.DodecahedronGeometry(0.4, 0),
                new THREE.BoxGeometry(0.4, 0.4, 0.4, 4, 4, 4),
                new THREE.SphereGeometry(0.4, 8, 8),
                new THREE.TorusKnotGeometry(0.25, 0.12, 64, 16, 3, 4),
                new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16, 1, true),
                new THREE.TorusGeometry(0.35, 0.2, 8, 20),
                new THREE.CapsuleGeometry(0.2, 0.4, 4, 12)
            ];
        }

        async function startAR() {
            // 1. レンダラーを即時作成
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setPixelRatio(1); // 負荷軽減
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            try {
                // 2. 最も成功率の高い 'viewer' を優先しつつ ARを要求
                const session = await navigator.xr.requestSession('immersive-ar', {
                    optionalFeatures: ['local-floor', 'hand-tracking']
                });

                document.body.appendChild(renderer.domElement);
                document.getElementById('arBtn').style.display = 'none';

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                
                initGeos();
                mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
                scene.add(mesh);

                // 3. 参照空間の取得（失敗しにくいviewerからlocal-floorへ）
                xrRefSpace = await session.requestReferenceSpace('viewer');
                try {
                    const floorSpace = await session.requestReferenceSpace('local-floor');
                    xrRefSpace = floorSpace;
                } catch(e) { console.log("Local-floor not available, using viewer."); }

                await renderer.xr.setSession(session);
                
                // 4. 通信は最後に開始
                initPeer();
                renderer.setAnimationLoop(render);

                session.addEventListener('end', () => { window.location.reload(); });

            } catch (e) {
                alert("Critical Error: " + e.message);
                window.location.reload();
            }
        }

        document.getElementById('arBtn').onclick = startAR;

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => {
                conn.on('data', d => { window.mD = d; });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play().catch(e => {}); 
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            // 音トリガー形状変化
            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // 視線方向の算出
            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);

            // ハンドトラッキング
            let handPos = new THREE.Vector3();
            let count = 0;
            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    const tip = input.hand.get('index-finger-tip');
                    const pose = tip ? frame.getJointPose(tip, xrRefSpace) : null;
                    if (pose) {
                        handPos.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                        count++;
                    }
                }
            }

            // 反応
            if (count > 0) {
                mesh.position.lerp(handPos, 0.2); // 手の位置
                mesh.rotation.y += 0.05 + (d.high * 1.5);
            } else {
                mesh.position.lerp(gaze, 0.1); // 視線の先
                mesh.rotation.y += 0.02;
            }

            mesh.scale.setScalar(0.4 + (d.low * 3.0));
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
