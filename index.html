// --- 12種類の複雑な幾何学を生成 ---
        function createGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(1, 0.4, 128, 16), // 0: 混沌の結び目
                new THREE.IcosahedronGeometry(1.5, 1),        // 1: 水晶体
                new THREE.TorusGeometry(2, 0.05, 16, 100),    // 2: 無限の輪
                new THREE.OctahedronGeometry(1.5, 0),         // 3: ピラミッド
                new THREE.TorusKnotGeometry(1.5, 0.1, 200, 3, 3, 5), // 4: スパイラル
                new THREE.BoxGeometry(2, 2, 2, 4, 4, 4),      // 5: サイバーキューブ
                new THREE.DodecahedronGeometry(1.5, 0),       // 6: 12面体
                new THREE.TorusGeometry(1.5, 0.8, 12, 6),     // 7: 六角リング
                new THREE.SphereGeometry(1.5, 32, 32),        // 8: 生命の種
                new THREE.ConeGeometry(1.5, 3, 32, 1, true),  // 9: 円錐
                new THREE.TorusKnotGeometry(1.2, 0.6, 64, 4), // 10: 肥大する結び目
                new THREE.CapsuleGeometry(1, 2, 4, 16)        // 11: カプセル
            ];
        }

        // --- Render内の演出ロジック強化 ---
        function render(time, frame) {
            hue += 0.005;

            // 1. Macからの低音トリガーでモードをランダムザッピング
            if (macData.trigger && Date.now() - lastSwitch > 600) {
                currentIdx = Math.floor(Math.random() * 12);
                mesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            // 2. ハンドトラッキング：手の位置に「吸い付く」ような滑らかな移動
            if (frame) {
                const sources = frame.session.inputSources;
                for (const input of sources) {
                    if (input.hand) {
                        const tip = frame.getJointPose(input.hand.get('index-finger-tip'), renderer.xr.getReferenceSpace());
                        const wrist = frame.getJointPose(input.hand.get('wrist'), renderer.xr.getReferenceSpace());
                        
                        if (tip && wrist) {
                            const tPos = tip.transform.position;
                            const wPos = wrist.transform.position;
                            
                            // 滑らかに追従（Lerp）
                            const targetPos = new THREE.Vector3(tPos.x, tPos.y, tPos.z);
                            mesh.position.lerp(targetPos, 0.2);

                            // 指の開き具合を「トゲトゲ度」や「サイズ」に反映
                            const spread = Math.hypot(tPos.x - wPos.x, tPos.y - wPos.y, tPos.z - wPos.z);
                            const dynamicScale = 0.5 + (spread * 5) + (macData.low * 2);
                            mesh.scale.setScalar(dynamicScale);
                        }
                    }
                }
            }

            // 3. 視線連動：見ている方向にオブジェクトが少し傾く
            const lookVec = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            mesh.rotation.x += 0.01 + macData.mid * 0.1;
            mesh.rotation.y += 0.02 + macData.high * 0.2;
            
            // 4. サイケデリック・カラー
            // 低音で発光、高音で色相が高速回転
            const targetColor = new THREE.Color();
            targetColor.setHSL((hue + macData.mid + (currentIdx * 0.08)) % 1, 0.8, 0.5 + macData.low * 0.3);
            mesh.material.color.lerp(targetColor, 0.1);
            mesh.material.opacity = 0.4 + macData.low * 0.6;

            renderer.render(scene, camera);
        }
        
