<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Psy-AR Ultra</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #arBtn { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 60px 100px; font-size: 30px; background: #00ffff; color: #000; border: none; border-radius: 20px; z-index: 1000; cursor: pointer; font-weight: bold; }
        #flashOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; z-index: 999; pointer-events: none; transition: opacity 0.05s ease-out; }
    </style>
</head>
<body>
    <button id="arBtn">START PSY-AR</button>
    <div id="flashOverlay"></div>
    <audio id="audio" autoplay playsinline></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script>
        let scene, camera, renderer, mesh, xrRefSpace, geometries = [];
        let macData = { low: 0, mid: 0, high: 0, trigger: false }; // highを追加
        let currentIdx = 0, lastSwitch = 0, hue = 0;
        const audio = document.getElementById('audio');
        const flashOverlay = document.getElementById('flashOverlay');
        let trailMeshes = [];

        window.onclick = () => { if (audio.srcObject) audio.play(); };

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.xr.enabled = true;
        
        // 24 Psychedelic Patterns
        geometries = [
            new THREE.TorusKnotGeometry(0.5, 0.15, 128, 16), new THREE.IcosahedronGeometry(0.5, 1),
            new THREE.TorusGeometry(0.6, 0.1, 16, 100), new THREE.BoxGeometry(0.6, 0.6, 0.6, 4, 4, 4),
            new THREE.OctahedronGeometry(0.6, 0), new THREE.DodecahedronGeometry(0.6, 0),
            new THREE.SphereGeometry(0.5, 32, 32), new THREE.CylinderGeometry(0.4, 0.4, 0.8, 32),
            new THREE.TorusKnotGeometry(0.5, 0.05, 150, 3, 3, 5), new THREE.ConeGeometry(0.5, 1, 32),
            new THREE.TorusGeometry(0.5, 0.2, 8, 6), new THREE.CapsuleGeometry(0.3, 0.6, 4, 16),
            new THREE.TorusKnotGeometry(0.4, 0.2, 80, 2, 5, 2), // New patterns
            new THREE.TetrahedronGeometry(0.6, 0),
            new THREE.SphereGeometry(0.5, 8, 8),
            new THREE.BoxGeometry(0.4, 0.8, 0.4, 2, 4, 2),
            new THREE.PlaneGeometry(1, 1, 10, 10),
            new THREE.ExtrudeGeometry(new THREE.Shape().absarc(0, 0, 0.3, 0, Math.PI * 2, false), {depth: 0.1, bevelEnabled: false}),
            new THREE.LatheGeometry([new THREE.Vector2(0,0), new THREE.Vector2(0.2,0.1), new THREE.Vector2(0.3,0.3), new THREE.Vector2(0.2,0.5), new THREE.Vector2(0,0.6)], 32),
            new THREE.RingGeometry(0.2, 0.4, 32, 8),
            new THREE.TorusKnotGeometry(0.3, 0.1, 96, 4, 7, 2),
            new THREE.PolyhedronGeometry(0.5, 1),
            new THREE.CylinderGeometry(0.2, 0.6, 1.2, 16),
            new THREE.DodecahedronGeometry(0.4, 0)
        ];
        mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, transparent: true, opacity: 0.8 }));
        scene.add(mesh);

        const btn = document.getElementById('arBtn');
        btn.onclick = () => {
            navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['local-floor', 'hand-tracking'] }).then(session => {
                btn.style.display = 'none';
                renderer.xr.setSession(session);
                session.requestReferenceSpace('local-floor').then(ref => { xrRefSpace = ref; initPeer(); renderer.setAnimationLoop(render); });
            });
        };

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => conn.on('data', data => macData = data));
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', stream => { audio.srcObject = stream; audio.play(); });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;

            // Flash effect on strong low trigger
            if (macData.trigger && macData.low > 0.9) {
                flashOverlay.style.opacity = 0.5;
                setTimeout(() => flashOverlay.style.opacity = 0, 100);
            }

            // Trigger Shape Change
            if (macData.trigger && Date.now() - lastSwitch > 400) { // Faster switching
                currentIdx = (currentIdx + 1) % geometries.length;
                mesh.geometry = geometries[currentIdx];
                lastSwitch = Date.now();
            }

            // Capture Head Direction (Look At) and Hand Tracking with Offset
            const lookVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Apply slight rotation based on gaze
            mesh.rotation.x += lookVector.y * 0.05; 
            mesh.rotation.z += lookVector.x * 0.05;

            let handDetected = false;
            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    const pose = frame.getJointPose(input.hand.get('index-finger-tip'), xrRefSpace);
                    if (pose) {
                        handDetected = true;
                        const targetPos = new THREE.Vector3().copy(pose.transform.position);
                        
                        // Add look-based push/pull effect
                        targetPos.add(lookVector.clone().multiplyScalar(0.2)); 

                        // High-frequency jitter based on macData.high
                        const jitter = macData.high * 0.05; // Adjust jitter intensity
                        targetPos.x += (Math.random() - 0.5) * jitter;
                        targetPos.y += (Math.random() - 0.5) * jitter;
                        targetPos.z += (Math.random() - 0.5) * jitter;

                        mesh.position.lerp(targetPos, 0.2);

                        // Trail effect: Create a small instance of the current mesh
                        if (time % 5 == 0 && trailMeshes.length < 50) { // Limit trail count
                            const trailMesh = new THREE.Mesh(mesh.geometry, mesh.material.clone());
                            trailMesh.position.copy(mesh.position);
                            trailMesh.quaternion.copy(mesh.quaternion);
                            trailMesh.scale.copy(mesh.scale);
                            trailMesh.material.opacity = 0.3; // Start fading
                            scene.add(trailMesh);
                            trailMeshes.push({ mesh: trailMesh, startTime: time });
                        }
                    }
                }
            }

            // Update and fade trails
            for (let i = trailMeshes.length - 1; i >= 0; i--) {
                const trail = trailMeshes[i];
                const age = (time - trail.startTime) / 200; // Trail duration
                if (age > 1) {
                    scene.remove(trail.mesh);
                    trailMeshes.splice(i, 1);
                } else {
                    trail.mesh.material.opacity = (0.3 * (1 - age)); // Fade out
                    trail.mesh.scale.multiplyScalar(0.98); // Shrink slightly
                }
            }

            // Fallback for no hand detected: float in front of camera
            if (!handDetected) {
                const idlePos = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).add(camera.position);
                mesh.position.lerp(idlePos, 0.05);
                mesh.rotation.y += 0.01;
            } else {
                // If hand detected, add high-freq rotation
                mesh.rotation.y += 0.02 + macData.high * 0.5; // High-freq adds more rotation
                mesh.rotation.x += macData.high * 0.3;
            }

            // Audio Visuals (Scale and Color)
            mesh.scale.setScalar(0.8 + macData.low * 2.5); // Base scale 0.8
            mesh.material.color.setHSL((hue + macData.mid) % 1, 1, 0.5 + macData.low * 0.2 + macData.high * 0.1); // Color brightens with high-freq
            mesh.material.opacity = 0.5 + (macData.low * 0.5);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
