<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR HARD-START</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 80px; font-size: 40px; background: #00ff00; color: #000; 
            border: 10px solid #fff; border-radius: 40px; z-index: 99999; 
            font-weight: bold; cursor: pointer; box-shadow: 0 0 50px #0f0;
        }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <audio id="audio" autoplay playsinline></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        // 12パターンの高精細幾何学
        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 150, 20, 2, 3),
                new THREE.IcosahedronGeometry(0.5, 2),
                new THREE.TorusGeometry(0.5, 0.2, 32, 100),
                new THREE.OctahedronGeometry(0.6, 0),
                new THREE.TorusKnotGeometry(0.4, 0.05, 200, 32, 7, 11),
                new THREE.DodecahedronGeometry(0.5, 1),
                new THREE.BoxGeometry(0.5, 0.5, 0.5, 8, 8, 8),
                new THREE.SphereGeometry(0.5, 12, 12),
                new THREE.TorusKnotGeometry(0.3, 0.15, 128, 32, 3, 4),
                new THREE.CylinderGeometry(0.4, 0.4, 1, 32, 1, true),
                new THREE.TorusGeometry(0.4, 0.3, 10, 8),
                new THREE.CapsuleGeometry(0.3, 0.4, 8, 16)
            ];
        }

        const btn = document.getElementById('arBtn');
        btn.addEventListener('click', () => {
            // WebXRセッションの開始（これより前に他処理を挟まない）
            if (navigator.xr) {
                navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor', 'hand-tracking']
                }).then(onSessionStarted).catch(err => {
                    alert("AR起動エラー: " + err.message);
                    window.location.reload(); // 失敗したら即リロード
                });
            } else {
                alert("このブラウザはWebXRに対応していません。");
            }
        });

        function onSessionStarted(session) {
            btn.style.display = 'none';
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            initGeos();
            mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
            scene.add(mesh);

            session.requestReferenceSpace('local-floor').then(ref => {
                xrRefSpace = ref;
                renderer.xr.setSession(session);
                initPeer(); // セッション確立後に通信開始
                renderer.setAnimationLoop(render);
            });

            session.addEventListener('end', () => window.location.reload());
        }

        function initPeer() {
            const peer = new Peer('quest-receiver-' + Math.floor(Math.random()*1000));
            peer.on('open', (id) => console.log("Peer ID: " + id)); // IDが変わるのでMac側で要確認
            peer.on('connection', conn => {
                conn.on('data', d => {
                    window.mD.low = d.low || 0;
                    window.mD.mid = d.mid || 0;
                    window.mD.high = d.high || 0;
                    window.mD.trigger = !!d.trigger;
                });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play().catch(e => console.error(e));
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            // 音トリガーで形状変化
            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // 視線方向の計算
            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);

            // ハンドトラッキングの完全同期
            let handPos = new THREE.Vector3();
            let count = 0;
            let pinchFactor = 0;

            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    // 人差し指の指先をメインに、全指の平均を取る
                    const joints = ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-tip'];
                    joints.forEach(j => {
                        const joint = input.hand.get(j);
                        if (joint) {
                            const pose = frame.getJointPose(joint, xrRefSpace);
                            if (pose) {
                                handPos.x += pose.transform.position.x;
                                handPos.y += pose.transform.position.y;
                                handPos.z += pose.transform.position.z;
                                count++;
                            }
                        }
                    });
                }
            }

            if (count > 0) {
                const avgPos = new THREE.Vector3(handPos.x / count, handPos.y / count, handPos.z / count);
                // 視線と手の位置をブレンド（見ている方向の手元に吸い付く）
                mesh.position.lerp(avgPos.lerp(gaze, 0.2), 0.2);
                mesh.rotation.y += 0.05 + (d.high * 2.0);
            } else {
                mesh.position.lerp(gaze, 0.1);
                mesh.rotation.y += 0.02;
            }

            // スケールと色
            const s = (0.5 + (d.low * 4.0));
            mesh.scale.setScalar(s);
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
