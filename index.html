<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR RESILIENT</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 50px 70px; font-size: 32px; background: #fff; color: #000; 
            border: 10px solid #0f0; border-radius: 20px; z-index: 10000; font-weight: bold;
        }
    </style>
</head>
<body>
    <button id="arBtn">FORCE START AR</button>
    <audio id="audio" autoplay playsinline style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 128, 16, 2, 3),
                new THREE.IcosahedronGeometry(0.4, 1),
                new THREE.TorusGeometry(0.4, 0.15, 16, 100),
                new THREE.OctahedronGeometry(0.5, 0),
                new THREE.TorusKnotGeometry(0.3, 0.05, 128, 32, 7, 11),
                new THREE.DodecahedronGeometry(0.4, 0),
                new THREE.BoxGeometry(0.4, 0.4, 0.4, 4, 4, 4),
                new THREE.SphereGeometry(0.4, 8, 8),
                new THREE.TorusKnotGeometry(0.25, 0.12, 64, 16, 3, 4),
                new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16, 1, true),
                new THREE.TorusGeometry(0.35, 0.2, 8, 20),
                new THREE.CapsuleGeometry(0.2, 0.4, 4, 12)
            ];
        }

        async function startAR() {
            // エラー回避のため、まず既存のレンダリングがあればクリア
            if (renderer) renderer.dispose();

            try {
                // 'hand-tracking'をrequiredからoptionalに変更し、起動の失敗率を激減させる
                const session = await navigator.xr.requestSession('immersive-ar', {
                    optionalFeatures: ['local-floor', 'hand-tracking']
                });

                document.getElementById('arBtn').style.display = 'none';

                renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
                renderer.xr.enabled = true;
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                
                initGeos();
                mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
                scene.add(mesh);

                // local-floor を試み、ダメなら viewer にフォールバック
                try {
                    xrRefSpace = await session.requestReferenceSpace('local-floor');
                } catch(e) {
                    xrRefSpace = await session.requestReferenceSpace('viewer');
                }

                await renderer.xr.setSession(session);
                initPeer();
                renderer.setAnimationLoop(render);

                session.addEventListener('end', () => { window.location.reload(); });

            } catch (e) {
                // エラーが出た場合、ブラウザがフリーズしないよう1秒後に強制リロード
                console.error(e);
                alert("起動に失敗しました。ページをリロードして3秒待ってから、ゆっくりボタンを押してください。");
                setTimeout(() => window.location.reload(), 1000);
            }
        }

        document.getElementById('arBtn').onclick = startAR;

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => {
                conn.on('data', d => { window.mD = d; });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play().catch(e => {}); 
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);

            // 指10本（全部の関節）を取得対象にして、より反応を良くする
            let handPos = new THREE.Vector3();
            let count = 0;
            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    // 全指の先端と手首を平均化して「塊」として扱う
                    const joints = ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-tip', 'wrist'];
                    joints.forEach(name => {
                        const joint = input.hand.get(name);
                        const pose = joint ? frame.getJointPose(joint, xrRefSpace) : null;
                        if (pose) {
                            handPos.x += pose.transform.position.x;
                            handPos.y += pose.transform.position.y;
                            handPos.z += pose.transform.position.z;
                            count++;
                        }
                    });
                }
            }

            if (count > 0) {
                const avgPos = new THREE.Vector3(handPos.x / count, handPos.y / count, handPos.z / count);
                mesh.position.lerp(avgPos, 0.2); 
                mesh.rotation.y += 0.05 + (d.high * 2.0);
            } else {
                mesh.position.lerp(gaze, 0.1); 
                mesh.rotation.y += 0.02;
            }

            mesh.scale.setScalar(0.4 + (d.low * 4.0));
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
