<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PSY-AR RESET & START</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #arBtn { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            padding: 50px; font-size: 30px; background: #00ff00; color: #000; 
            border: none; border-radius: 30px; z-index: 1000; font-weight: bold; cursor: pointer;
        }
        #status { position: fixed; bottom: 20px; width: 100%; text-align: center; color: #555; font-size: 14px; }
    </style>
</head>
<body>
    <button id="arBtn">START AR</button>
    <div id="status">Waiting for system...</div>
    <audio id="audio" autoplay playsinline></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, mesh, xrRefSpace;
        let geometries = [];
        window.mD = { low: 0, mid: 0, high: 0, trigger: false };
        let lastSwitch = 0, hue = 0;

        // 12パターンの形状を事前に生成
        function initGeos() {
            geometries = [
                new THREE.TorusKnotGeometry(0.3, 0.1, 128, 16, 2, 3),
                new THREE.IcosahedronGeometry(0.5, 2),
                new THREE.TorusGeometry(0.4, 0.2, 32, 100),
                new THREE.OctahedronGeometry(0.6, 0),
                new THREE.TorusKnotGeometry(0.4, 0.05, 200, 32, 7, 11),
                new THREE.DodecahedronGeometry(0.5, 1),
                new THREE.BoxGeometry(0.5, 0.5, 0.5, 10, 10, 10),
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.TorusKnotGeometry(0.3, 0.15, 128, 32, 3, 4),
                new THREE.CylinderGeometry(0.4, 0.4, 1, 32, 1, true),
                new THREE.TorusGeometry(0.4, 0.3, 12, 6),
                new THREE.CapsuleGeometry(0.3, 0.4, 8, 16)
            ];
        }

        const btn = document.getElementById('arBtn');
        const status = document.getElementById('status');

        // AR起動関数
        async function startAR() {
            try {
                // 以前のセッションのゴミを掃除するため、optionalFeaturesで柔軟に要求
                const session = await navigator.xr.requestSession('immersive-ar', {
                    optionalFeatures: ['local-floor', 'hand-tracking']
                });
                onSessionStarted(session);
            } catch (e) {
                status.innerText = "Error: " + e.message;
                // 致命的なエラー時は3秒後に自動リロードしてシステムをクリーンにする
                setTimeout(() => window.location.reload(), 3000);
            }
        }

        btn.onclick = () => {
            btn.style.display = 'none';
            status.innerText = "Initializing AR...";
            startAR();
        };

        function onSessionStarted(session) {
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.xr.enabled = true;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            initGeos();
            mesh = new THREE.Mesh(geometries[0], new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 }));
            scene.add(mesh);

            session.requestReferenceSpace('local-floor').then(ref => {
                xrRefSpace = ref;
                renderer.xr.setSession(session);
                initPeer();
                renderer.setAnimationLoop(render);
            });

            session.addEventListener('end', () => window.location.reload());
        }

        function initPeer() {
            const peer = new Peer('quest-receiver');
            peer.on('connection', conn => {
                conn.on('data', d => {
                    window.mD = { ...window.mD, ...d };
                });
            });
            peer.on('call', call => {
                call.answer(new MediaStream());
                call.on('stream', s => { 
                    const aud = document.getElementById('audio');
                    aud.srcObject = s; aud.play(); 
                });
            });
        }

        function render(time, frame) {
            if (!frame || !xrRefSpace) return;
            hue += 0.005;
            const d = window.mD;

            // 音トリガー形状変化
            if (d.trigger && (Date.now() - lastSwitch > 300)) {
                mesh.geometry = geometries[Math.floor(Math.random() * geometries.length)];
                lastSwitch = Date.now();
            }

            // ハンドトラッキング & 視線追従
            const gaze = new THREE.Vector3(0, 0, -0.6).applyQuaternion(camera.quaternion).add(camera.position);
            let handPos = new THREE.Vector3(), count = 0;

            for (const input of frame.session.inputSources) {
                if (input.hand) {
                    const joint = input.hand.get('index-finger-tip');
                    const pose = joint ? frame.getJointPose(joint, xrRefSpace) : null;
                    if (pose) {
                        handPos.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                        count++;
                    }
                }
            }

            if (count > 0) {
                mesh.position.lerp(handPos, 0.2); // 手の位置へ
                mesh.rotation.y += 0.05 + (d.high * 2.0);
            } else {
                mesh.position.lerp(gaze, 0.1); // 手がない時は視線の先
                mesh.rotation.y += 0.02;
            }

            mesh.scale.setScalar(0.4 + (d.low * 4.0));
            mesh.material.color.setHSL((hue + d.mid) % 1, 1, 0.5);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
