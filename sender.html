// --- Global reference for Reference Space ---
let xrRefSpace = null;
const audio = document.getElementById('remoteAudio');

// --- Force Audio Play on AR Screen Tap ---
window.addEventListener('click', () => {
    if (audio && audio.srcObject) {
        audio.muted = false; // Ensure it's not muted
        audio.play()
            .then(() => console.log("Audio playing"))
            .catch(e => console.error("Audio failed", e));
    }
});

function setupXR(session) {
    // ... (previous setup code) ...
    
    // Capture the reference space for the render loop
    session.requestReferenceSpace('local-floor').then((refSpace) => {
        xrRefSpace = refSpace;
        renderer.xr.setSession(session);
        renderer.setAnimationLoop(render);
    });
}

function render(time, frame) {
    if (!frame || !xrRefSpace) return;
    hue += 0.005;

    // --- Audio Auto-Resume ---
    if (audio.srcObject && audio.paused) {
        audio.play().catch(() => { /* Still waiting for user interaction */ });
    }

    // --- Mode Switching (Mac Trigger) ---
    if (macData.trigger && (Date.now() - lastSwitch > 700)) {
        currentIdx = (currentIdx + 1) % geometries.length;
        mesh.geometry = geometries[currentIdx];
        lastSwitch = Date.now();
    }

    // --- Hand Tracking & Lerp Smoothing ---
    const session = frame.session;
    let handDetected = false;

    for (const input of session.inputSources) {
        if (input.hand) {
            const indexTip = input.hand.get('index-finger-tip');
            const pose = frame.getJointPose(indexTip, xrRefSpace);
            
            if (pose) {
                // Smoothly follow the index finger
                const targetPos = new THREE.Vector3().copy(pose.transform.position);
                mesh.position.lerp(targetPos, 0.15);
                
                // Optional: Smoothly follow hand orientation
                const targetQuat = new THREE.Quaternion().copy(pose.transform.orientation);
                mesh.quaternion.slerp(targetQuat, 0.1);
                
                handDetected = true;
            }
        }
    }

    // Default rotation if no hand is visible
    if (!handDetected) {
        mesh.rotation.y += 0.01;
        // Float in front of the camera if lost
        const headPos = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        mesh.position.lerp(headPos.add(camera.position), 0.05);
    }

    // --- Audio Reactive Visuals ---
    const s = 1 + (macData.low * 3);
    mesh.scale.setScalar(s);
    
    // Psychedelic color shifting
    mesh.material.color.setHSL((hue + macData.mid) % 1, 0.8, 0.5 + macData.low * 0.2);
    mesh.material.opacity = 0.5 + (macData.low * 0.5);

    renderer.render(scene, camera);
}
